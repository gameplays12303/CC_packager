local Argue = {...}
local expect = require("cc.expect").expect
local Path
if true
then
    Path = expect(1,Argue[1],"string","nil") or ""
    if not fs.exists(Path) 
    then
        error(("%s not found"):format(Path),2)
    end
    if not fs.isDir(Path)
    then
        error(("%s is not directory"):format(Path),2)
    end
end
local programs = textutils.unserialise("{\
  {\
    func = \"local expect = ((require and require(\\\"cc.expect\\\")) or dofile(\\\"/rom/modules/main/cc/expect.lua\\\",_ENV)).expect\\\
local insert = table.insert\\\
local open = fs.open\\\
local exists = fs.exists\\\
local fm = {}\\\
---@overload fun(sPath:string,data:any,mode:string)\\\
function fm.OverWrite(sPath,data,mode)\\\
    expect(1,sPath,\\\"string\\\")\\\
    expect(3,mode,\\\"string\\\")\\\
    expect(4,Owner,\\\"string\\\",\\\"nil\\\")\\\
    mode = mode or \\\"S\\\"\\\
    if mode ~= \\\"S\\\" and mode ~= \\\"R\\\"\\\
    then\\\
        error(\\\"Invalid mode\\\",2)\\\
    end\\\
    local file,mess = open(sPath,\\\"w\\\")\\\
    if file == nil then\\\
        return error(mess,0)\\\
    end\\\
    if mode == \\\"R\\\"\\\
    then\\\
        file.write(data)\\\
    else\\\
        file.write(textutils.serialise(data))\\\
    end\\\
    file.close()\\\
    return true\\\
end\\\
---@overload fun(sPath:string,data:any,mode:string,Owner:string,isReadOnly:boolean,Hidden:boolean,Shared:table)\\\
function fm.WriteLine(sPath,data,mode)\\\
    expect(1,sPath,\\\"string\\\")\\\
    expect(3,mode,\\\"string\\\")\\\
    mode = mode or \\\"S\\\"\\\
    if mode ~= \\\"S\\\" and mode ~= \\\"R\\\"\\\
    then\\\
        error(\\\"Invalid mode\\\",2)\\\
    end\\\
    local file,mess = open(sPath,\\\"a\\\")\\\
    if file == nil then\\\
        return error(mess,0)\\\
    end\\\
    if mode == \\\"R\\\"\\\
    then\\\
        file.write(data)\\\
    else\\\
        file.write(textutils.serialise(data))\\\
    end\\\
    file.close()\\\
    return true\\\
end\\\
---@overload fun(sPath:string,mode:string)\\\
function fm.readFile(sPath,mode)\\\
    expect(1,sPath,\\\"string\\\")\\\
    expect(3,mode,\\\"string\\\")\\\
    mode = mode or \\\"S\\\"\\\
    if mode ~= \\\"S\\\" and mode ~= \\\"R\\\"\\\
    then\\\
        error(\\\"Invalid mode\\\",2)\\\
    end\\\
    if not exists(sPath) then\\\
        error(\\\"Invalid path \\\"..sPath..\\\" dose not exist\\\",0)\\\
    end\\\
    local file,mess = open(sPath,\\\"r\\\")\\\
    if file == nil then\\\
        return error(mess,0)\\\
    end\\\
    local data\\\
    if mode == \\\"R\\\"\\\
    then\\\
        data = file.readAll()\\\
    else\\\
        data = textutils.unserialise(file.readAll())\\\
    end\\\
    file.close()\\\
    return data\\\
end\\\
return fm\\\
\",\
    Path = \"package/modules/fm.lua\",\
  },\
  {\
    func = \"local expect = (require and require(\\\"cc.expect\\\") or dofile(\\\"rom/modules/main/cc/expect.lua\\\")).expect\\\
local pretty = require(\\\"cc.pretty\\\")\\\
local fs,string,table = fs,string,table\\\
local setmetatable = setmetatable\\\
local getmetatable = getmetatable\\\
local utilties = {}\\\
utilties.string = {}\\\
utilties.table = {}\\\
utilties.file = {}\\\
-- strings addons \\\
function utilties.string.split(inputstr, sep)\\\
    if sep == nil then\\\
        sep = \\\"%s\\\"\\\
    end\\\
    local t={}\\\
    for str in string.gmatch(inputstr, \\\"([^\\\"..sep..\\\"]+)\\\") do\\\
      table.insert(t, str)\\\
    end\\\
    return t\\\
end\\\
-- fs addons\\\
function utilties.file.created(sPath)\\\
      expect(1,sPath,\\\"string\\\")\\\
      return fs.attributes(sPath).created\\\
end\\\
function utilties.file.modified(sPath)\\\
      expect(1,sPath,\\\"string\\\")\\\
      return fs.attributes(sPath).modified\\\
end\\\
\\\
function utilties.file.getExtension(file)\\\
      expect(1,file,\\\"string\\\")\\\
	local Table = utilties.string.split(file,\\\"%.\\\")\\\
      return Table[2]\\\
end\\\
function utilties.file.withoutExtension(file)\\\
      expect(1,file,\\\"string\\\")\\\
      local Table = utilties.string.split(file,\\\"%.\\\")\\\
      return Table[1]\\\
end\\\
function utilties.file.listsubs(sPath,showFiles,showDirs,showRootDir,showRom)\\\
      expect(1,sPath,\\\"string\\\")\\\
      expect(2,showFiles,\\\"boolean\\\",\\\"nil\\\")\\\
      expect(3,showDirs,\\\"boolean\\\",\\\"nil\\\")\\\
      expect(5,showRootDir,\\\"boolean\\\",\\\"nil\\\")\\\
      expect(6,showRom,\\\"boolean\\\",\\\"nil\\\")\\\
      showDirs = showDirs or showRootDir\\\
      if not fs.exists(sPath) then\\\
            error(\\\"Could not find \\\"..fs.getName(sPath),2)\\\
      end\\\
      if not fs.isDir(sPath) then\\\
            error(fs.getName(sPath)..\\\"is not a directory\\\",2)\\\
      end\\\
      local Table = fs.find(sPath..\\\"/*\\\")\\\
      if not showRom\\\
      then\\\
            local ID = utilties.table.find(Table,\\\"rom\\\")\\\
            if ID\\\
            then\\\
                  table.remove(Table,ID)\\\
            end\\\
      end\\\
      local list = {}\\\
      if showRootDir\\\
      then\\\
            table.insert(list,sPath)\\\
      end\\\
      for _,v in pairs(Table) do\\\
            if fs.isDir(v)\\\
            then\\\
                  if showDirs\\\
                  then\\\
                        table.insert(list,v)\\\
                  end\\\
                  local list2 = fs.find(fs.combine(v,\\\"*\\\"))\\\
                  for _,i in pairs(list2) do\\\
                        if fs.isDir(i)\\\
                        then\\\
                              table.insert(Table,i)\\\
                        elseif showFiles\\\
                        then\\\
                              table.insert(list,i)\\\
                        end\\\
                  end\\\
            elseif showFiles\\\
            then\\\
                  table.insert(list,v)\\\
            end\\\
      end\\\
      return list\\\
end\\\
function utilties.file.list(_sPath,showFiles,showDirs,showPath)\\\
      expect(1,_sPath,\\\"string\\\")\\\
      expect(2,showFiles,\\\"boolean\\\",\\\"nil\\\")\\\
      expect(3,showDirs,\\\"boolean\\\",\\\"nil\\\")\\\
      expect(4,showPath,\\\"boolean\\\",\\\"nil\\\")\\\
      if not fs.exists(_sPath)\\\
      then\\\
            error((\\\"%s : not found\\\"):format(_sPath),3)\\\
      end\\\
      if not fs.isDir(_sPath)\\\
      then\\\
            error((\\\"%s: is file expected directory\\\"):format(_sPath),3)\\\
      end\\\
      local list = fs.find(fs.combine(_sPath,\\\"*\\\"))\\\
      local list2 = {}\\\
      for _,v in pairs(list) do\\\
            if fs.isDir(v) and showDirs\\\
            then\\\
                  table.insert(list2,v)\\\
            elseif not fs.isDir(v) and showFiles\\\
            then\\\
                  table.insert(list2,v)\\\
            end\\\
      end\\\
      if not showPath\\\
      then\\\
            for i,v in pairs(list2) do\\\
                  list2[i] = fs.getName(v)\\\
            end\\\
      end\\\
      return list2\\\
end\\\
function utilties.file.getDir(path)\\\
      expect(1,path,\\\"string\\\")\\\
      if fs.getDir(path) == \\\"..\\\"\\\
      then\\\
            return \\\"\\\"\\\
      else\\\
            return fs.getDir(path)\\\
      end\\\
end\\\
utilties.color = {}\\\
function utilties.color.isColor(color)\\\
      expect(1,color,\\\"number\\\")\\\
      for i,v in pairs(colors) do\\\
            if v == color\\\
            then\\\
                  return i\\\
            end\\\
      end\\\
      return false\\\
end\\\
-- table addons\\\
function utilties.table.find(base,ID)\\\
      expect(1,base,\\\"table\\\")\\\
      for i,v in pairs(base) do\\\
            if type(ID) == \\\"string\\\" and type(v) == \\\"string\\\"\\\
            then\\\
                  if string.find(v,ID)\\\
                  then\\\
                        return i\\\
                  end \\\
            else\\\
                  if ID == v\\\
                  then\\\
                        return i\\\
                  end\\\
            end\\\
      end\\\
return false\\\
end\\\
function utilties.table.copy(Table,proxy,copymetatable)\\\
      expect(1,Table,\\\"table\\\")\\\
      expect(2,proxy,\\\"table\\\",\\\"nil\\\")\\\
      proxy = proxy or {}\\\
      local metatable = getmetatable(Table)\\\
      for k,v in pairs(Table) do\\\
            if type(v) == \\\"table\\\" and not utilties.table.find(v,v)\\\
            then\\\
                  local Temp = utilties.table.copy(v)\\\
                  proxy[k] = Temp\\\
            elseif type(v) ~= \\\"table\\\"\\\
            then\\\
                  proxy[k] = v\\\
            end\\\
      end\\\
      if not table.disabledMetaTable and copymetatable\\\
      then\\\
            return setmetatable(proxy,metatable)\\\
      elseif table.disabledMetaTable and not table.disabledMetaTable(proxy) and copymetatable\\\
      then\\\
            return setmetatable(proxy,metatable)\\\
      end\\\
      return proxy\\\
end\\\
return utilties\",\
    Path = \"package/modules/utilties.lua\",\
  },\
  {\
    func = \"local expect = require(\\\"cc.expect\\\").expect\\\
local util = require(\\\"modules.utilties\\\")\\\
local fm  = require(\\\"modules.fm\\\")\\\
local argue = {...}\\\
--the Path to package up\\\
local LUA_PATH = expect(1,argue[1],\\\"string\\\")\\\
-- the installer Path\\\
local LUA_WRITE = expect(2,argue[2],\\\"string\\\") or \\\"\\\"\\\
LUA_WRITE = util.file.withoutExtension(LUA_WRITE)..\\\".LINS\\\"\\\
-- allows to specifi a installation Path when installing \\\
-- example \\\"../build/OS\\\" --> \\\"../OS\\\"\\\
-- the 'build' directory  is left out because it's not a part of the program just where it's stored\\\
-- set to true to make it a install anyWhere file \\\
local LUA_Install = expect(3,argue[3],\\\"string\\\",\\\"number\\\",\\\"boolean\\\",\\\"nil\\\")\\\
if LUA_Install and LUA_Install == \\\"false\\\"\\\
then\\\
    LUA_Install = false\\\
elseif LUA_Install and LUA_Install == \\\"true\\\"\\\
then\\\
    LUA_Install = true\\\
elseif LUA_Install\\\
then\\\
    LUA_Install = tonumber(LUA_Install)\\\
    if type(LUA_Install) == \\\"number\\\"\\\
    then\\\
        LUA_Install = LUA_Install +1\\\
    end\\\
end\\\
-- gets a list of programs and directorys to be packaged\\\
local Dir = util.file.listsubs(LUA_PATH,false,true,true,false)\\\
local files = util.file.listsubs(LUA_PATH,true,false,false,false)\\\
local sDir,sFiles = {},{}\\\
if LUA_Install and type(LUA_Install) == \\\"number\\\"\\\
then\\\
    for _,v in pairs(Dir) do\\\
        table.insert(sDir,util.string.split(v,\\\"%/\\\"))\\\
    end\\\
    for _,v in pairs(files) do\\\
        table.insert(sFiles,util.string.split(v,\\\"%/\\\"))\\\
    end\\\
\\\
    for i,v in pairs(sDir) do\\\
        sDir[i] = table.concat(v,\\\"/\\\",LUA_Install)\\\
    end\\\
    for i,v in pairs(sFiles) do\\\
        sFiles[i] = table.concat(v,\\\"/\\\",LUA_Install)\\\
    end\\\
else\\\
    sDir = Dir\\\
    sFiles = files\\\
end\\\
\\\
for i,v in pairs(sFiles) do\\\
    local temp = {\\\
        Path = v,\\\
        func = fm.readFile(files[util.table.find(files,v)],\\\"R\\\")\\\
    }\\\
    sFiles[i] = temp\\\
end\\\
-- time to build the run handler\\\
local runhanndle = [[\\\
local Argue = {...}\\\
local expect = require(\\\"cc.expect\\\").expect\\\
local Path\\\
if %q\\\
then\\\
    Path = expect(1,Argue[1],\\\"string\\\",\\\"nil\\\") or \\\"\\\"\\\
    if not fs.exists(Path) \\\
    then\\\
        error((\\\"%s not found\\\"):format(Path),2)\\\
    end\\\
    if not fs.isDir(Path)\\\
    then\\\
        error((\\\"%s is not directory\\\"):format(Path),2)\\\
    end\\\
end\\\
local programs = textutils.unserialise(%q)\\\
local Dirs = %s\\\
for _,v in pairs(Dirs) do\\\
if Path\\\
    then\\\
        fs.makeDir(fs.combine(Path,v))\\\
    else\\\
        fs.makeDir(v)\\\
    end\\\
end\\\
for _,v in pairs(programs) do\\\
    local file,mess\\\
    if Path\\\
    then\\\
        file,mess = fs.open(fs.combine(Path,v.Path),\\\"w\\\")\\\
    else\\\
        file,mess = fs.open(v.Path,\\\"w\\\")\\\
    end\\\
    if not file\\\
    then\\\
        error(mess,0)\\\
    end\\\
    file.write(v.func)\\\
    file.close()\\\
end\\\
]]\\\
if LUA_Install and type(LUA_Install) == \\\"boolean\\\"\\\
then\\\
    runhanndle = runhanndle:format(true,\\\"%s\\\",\\\"%s\\\",textutils.serialise(sFiles),textutils.serialise(sDir))\\\
else\\\
    runhanndle = runhanndle:format(false,\\\"%s\\\",\\\"%s\\\",textutils.serialise(sFiles),textutils.serialise(sDir))\\\
end\\\
fm.OverWrite(LUA_WRITE,runhanndle,\\\"R\\\")\",\
    Path = \"package/packager.lua\",\
  },\
}")
local Dirs = {
  "package",
  "package/modules",
}
for _,v in pairs(Dirs) do
if Path
    then
        fs.makeDir(fs.combine(Path,v))
    else
        fs.makeDir(v)
    end
end
for _,v in pairs(programs) do
    local file,mess
    if Path
    then
        file,mess = fs.open(fs.combine(Path,v.Path),"w")
    else
        file,mess = fs.open(v.Path,"w")
    end
    if not file
    then
        error(mess,0)
    end
    file.write(v.func)
    file.close()
end
